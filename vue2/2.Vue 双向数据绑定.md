# Vue 双向数据绑定

涉及到的技术

-   Object.defineProperty
-   Observer
-   Watcher
-   Dep
-   Directive

## 认识 Object.defineProperty

```js
function defineReactive(data, key, value) {
    Object.defineProperty(data, key, {
        configurable: true,
        enumerable: true,
        get: function () {
            console.log(`get ${value}`);
            return value;
        },
        set: function (newVal) {
            console.log(`set key: ${key} value ${newVal}`);
            value = newVal;
        }
    });
}

function observer(data) {
    Object.keys(data).forEach(key => {
        defineReactive(data, key, data[key]);
    });
}

let obj = { a: 1 };
let arr = [1, 2, 3];

observer(obj);
observer(arr);

arr.unshift(4);
// get 3
// get 2
// set key: 2 value 2
// get 1
// set key: 1 value 1
// set key: 0 value 4
```

object.defineProperty 可以对对象某个 key 值进行重写，只能重写已有的值，对于新增的 key 值无法重写。

执行 arr.unshift(4) 为什么频繁的触发 get 和 set？

因为数组在内存中的存储是连续的，存储的是数组的起始位置和长度。执行 arr.unshift(4)，会先增加数组长度，取出原先最后一位放到现在的最后一位。原先只对下标为 0，1，2 重写了 get，set 没有对新增的下标 3 重写，因此只会触发下标为 2 的 get，不触发下标为 3 的 set。同理一次对下标 0，1 做同样的操作。最后将要 4，填到下标为 0 的位置，即触发 0 的 set。

## 响应式数据原理

![observer](../images/observer.png)

### 数据监听过程

在 Vue 初始化阶段，执行 \_init 时会执行 initState(vm)。 initState 方法主要对 props、data、methods、computed、watch 进行初始化操作。这里重点分析 initProps 和 initData。

```js
// src/core/instance/state.js
export function initState(vm: Component) {
    vm._watchers = [];
    const opts = vm.$options;
    if (opts.props) initProps(vm, opts.props);
    if (opts.methods) initMethods(vm, opts.methods);
    if (opts.data) {
        initData(vm);
    } else {
        observe((vm._data = {}), true /* asRootData */);
    }
    if (opts.computed) initComputed(vm, opts.computed);
    if (opts.watch && opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch);
    }
}
```

**分析 initProps 和 initData：**

```js
// src/core/instance/state.js
function initProps(vm: Component, propsOptions: Object) {
    const propsData = vm.$options.propsData || {};
    const props = (vm._props = {});
    const keys = (vm.$options._propKeys = []);
    // ...代码省略
    for (const key in propsOptions) {
        keys.push(key);
        // ...代码省略
        defineReactive(props, key, value);
        if (!(key in vm)) {
            proxy(vm, `_props`, key);
        }
    }
    // ...代码省略
}

function initData(vm: Component) {
    let data = vm.$options.data;
    // ...代码省略
    // proxy data on instance
    const keys = Object.keys(data);
    const props = vm.$options.props;
    const methods = vm.$options.methods;
    let i = keys.length;
    while (i--) {
        const key = keys[i];
        // ...代码省略
        proxy(vm, `_data`, key);
    }
    // observe data
    observe(data, true /* asRootData */);
}
```

props 和 data 初始化过程主要做了两件事。

1. 通过 proxy 方法将数据代理到 vm 上。如：`vm._props.xxx ==> vm.xxx`
   `vm._data.xxx ==> vm.xxx`。
2. Vue 遵循单向数据流的原则，props 由父组件传递过来，因此无需 observer，直接使用 defineReactive 方法把 props 每个值变成响应式；而 data 需要进行 observer，在把 data 变成响应式。

**为什么要将数据代理到 vue 实例对象上？**

下面是一段 template 编译后的 js 代码

```html
<div id="app">
    <div>
        <h2 v-if="message">{{message}}</h2>
        <button @click="showName">showName</button>
        <div v-if="v">
            <div>
                <p>我爱你</p>
                <p>你爱我</p>
                <p>蜜雪冰城甜蜜蜜</p>
            </div>
        </div>
    </div>
</div>
```

```js
// this ==> vm
with (this) {
    return _c('div', { attrs: { id: 'app' } }, [
        _c('div', [
            message ? _c('h2', [_v(_s(message))]) : _e(),
            _v(' '),
            _c('button', { on: { click: showName } }, [_v('showName')]),
            _v(' '),
            v ? _c('div', [_m(0)]) : _e()
        ])
    ]);
}
```

可以看到 Vue 使用 with 将 this（实例对象）插入到作用域链，因此会访问到实例上的变量，这就解释了为什么要将数据代理到实例对象上。

**分析 observer：**

observe 的功能就是用来监测数据的变化，它的定义在 src/core/observer/index.js 中：

```js
export function observe(value: any, asRootData: ?boolean): Observer | void {
    if (!isObject(value) || value instanceof VNode) {
        return;
    }
    let ob: Observer | void;
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
        ob = value.__ob__;
    } else if (
        shouldObserve &&
        !isServerRendering() &&
        (Array.isArray(value) || isPlainObject(value)) &&
        Object.isExtensible(value) &&
        !value._isVue
    ) {
        ob = new Observer(value); //
    }
    if (asRootData && ob) {
        ob.vmCount++;
    }
    return ob;
}
```

observe 方法的作用就是给非 VNode 的对象类型数据添加一个 Observer，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 Observer 对象实例。

```js
export class Observer {
    value: any;
    dep: Dep;
    vmCount: number; // number of vms that have this object as root $data

    constructor(value: any) {
        this.value = value;
        this.dep = new Dep();
        this.vmCount = 0;
        def(value, '__ob__', this);
        if (Array.isArray(value)) {
            if (hasProto) {
                // [12，4334，].__proto__= arrayMethods
                protoAugment(value, arrayMethods);
            } else {
                copyAugment(value, arrayMethods, arrayKeys);
            }
            this.observeArray(value);
        } else {
            this.walk(value);
        }
    }

    walk(obj: Object) {
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
            defineReactive(obj, keys[i]);
        }
    }

    observeArray(items: Array<any>) {
        for (let i = 0, l = items.length; i < l; i++) {
            observe(items[i]);
        }
    }
}
```

Observer 的作用就是重写对象的 getter 和 setter，用于依赖收集和派发更新。

Vue 会对 Array 和 Object 分别处理，对象类型直接调用 defineReactive 进行处理，而数组类型是调用 protoAugment 或 copyAugment 处理（重写原型方法）。

**defineReactive：**

```js
export function defineReactive(
    obj: Object,
    key: string,
    val: any,
    customSetter?: ?Function,
    shallow?: boolean
) {
    const dep = new Dep();
    const property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
        return;
    }

    // cater for pre-defined getter/setters
    const getter = property && property.get;
    const setter = property && property.set;
    if ((!getter || setter) && arguments.length === 2) {
        val = obj[key];
    }

    let childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
            const value = getter ? getter.call(obj) : val;
            if (Dep.target) {
                dep.depend();
                if (childOb) {
                    childOb.dep.depend();
                    if (Array.isArray(value)) {
                        dependArray(value);
                    }
                }
            }
            return value;
        },
        set: function reactiveSetter(newVal) {
            const value = getter ? getter.call(obj) : val;
            /* eslint-disable no-self-compare */
            if (newVal === value || (newVal !== newVal && value !== value)) {
                return;
            }
            /* eslint-enable no-self-compare */
            if (process.env.NODE_ENV !== 'production' && customSetter) {
                customSetter();
            }
            // #7981: for accessor properties without setter
            if (getter && !setter) return;
            if (setter) {
                setter.call(obj, newVal);
            } else {
                val = newVal;
            }
            childOb = !shallow && observe(newVal);
            dep.notify(); // 通知，数据被修改
        }
    });
}
```

defineReactive 函数最开始初始化 Dep 对象的实例，接着拿到 obj 的属性描述符，然后对子对象递归调用 observe 方法，这样就保证了无论 obj 的结构多复杂，它的所有子属性也能变成响应式的对象，这样我们访问或修改 obj 中一个嵌套较深的属性，也能触发 getter 和 setter。最后利用 Object.defineProperty 去给 obj 的属性 key 添加 getter 和 setter。

### 依赖收集

当对数据对象的访问会触发他们的 getter 方法，那么这些对象什么时候被访问呢？

Vue 的 mount 过程是通过 mountComponent 函数，mountComponent 会通过 render 函数生成 VNode，这时会触发 getter。

```js
// src/core/instance/lifecycle.js
export function mountComponent(vm: Component, el: ?Element, hydrating?: boolean): Component {
    //...代码省略
    updateComponent = () => {
        //TAG:绑定render
        vm._update(vm._render(), hydrating);
    };

    new Watcher(
        vm,
        updateComponent,
        noop,
        {
            before() {
                if (vm._isMounted && !vm._isDestroyed) {
                    callHook(vm, 'beforeUpdate');
                }
            }
        },
        true /* isRenderWatcher */
    );
}
```

先看 Watcher 和 Dep 的代码

```js
import type Watcher from './watcher';
import { remove } from '../util/index';

let uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
export default class Dep {
    static target: ?Watcher;
    id: number;
    subs: Array<Watcher>;

    constructor() {
        this.id = uid++;
        this.subs = [];
    }

    addSub(sub: Watcher) {
        this.subs.push(sub);
    }

    removeSub(sub: Watcher) {
        remove(this.subs, sub);
    }

    depend() {
        if (Dep.target) {
            Dep.target.addDep(this);
        }
    }

    notify() {
        // stabilize the subscriber list first
        const subs = this.subs.slice();
        for (let i = 0, l = subs.length; i < l; i++) {
            subs[i].update();
        }
    }
}

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
const targetStack = [];

export function pushTarget(_target: ?Watcher) {
    if (Dep.target) targetStack.push(Dep.target);
    Dep.target = _target;
}

export function popTarget() {
    Dep.target = targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
}
```

Dep 是一个 Class，它定义了一些属性和方法，这里需要特别注意的是它有一个静态属性 target，会存储全局唯一 Watcher，因为在同一时间只能有一个全局的 Watcher 被计算，另外它的自身属性 subs 也是 Watcher 的数组。

```js
// src/core/observer/watcher.js
let uid = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
export default class Watcher {
    vm: Component;
    expression: string;
    cb: Function;
    id: number;
    deep: boolean;
    user: boolean;
    computed: boolean;
    sync: boolean;
    dirty: boolean;
    active: boolean;
    dep: Dep;
    deps: Array<Dep>;
    newDeps: Array<Dep>;
    depIds: SimpleSet;
    newDepIds: SimpleSet;
    before: ?Function;
    getter: Function;
    value: any;

    constructor(
        vm: Component,
        expOrFn: string | Function,
        cb: Function,
        options?: ?Object,
        isRenderWatcher?: boolean
    ) {
        this.vm = vm;
        if (isRenderWatcher) {
            vm._watcher = this;
        }
        vm._watchers.push(this);
        // options
        if (options) {
            this.deep = !!options.deep;
            this.user = !!options.user;
            this.computed = !!options.computed;
            this.sync = !!options.sync;
            this.before = options.before;
        } else {
            this.deep = this.user = this.computed = this.sync = false;
        }
        this.cb = cb;
        this.id = ++uid; // uid for batching
        this.active = true;
        this.dirty = this.computed; // for computed watchers
        this.deps = [];
        this.newDeps = [];
        this.depIds = new Set();
        this.newDepIds = new Set();
        this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
        // parse expression for getter
        if (typeof expOrFn === 'function') {
            this.getter = expOrFn;
        } else {
            this.getter = parsePath(expOrFn);
            if (!this.getter) {
                this.getter = function () {};
                process.env.NODE_ENV !== 'production' &&
                    warn(
                        `Failed watching path: "${expOrFn}" ` +
                            'Watcher only accepts simple dot-delimited paths. ' +
                            'For full control, use a function instead.',
                        vm
                    );
            }
        }
        if (this.computed) {
            this.value = undefined;
            this.dep = new Dep();
        } else {
            this.value = this.get();
        }
    }

    /**
     * Evaluate the getter, and re-collect dependencies.
     */
    get() {
        pushTarget(this);
        let value;
        const vm = this.vm;
        try {
            value = this.getter.call(vm, vm);
        } catch (e) {
            if (this.user) {
                handleError(e, vm, `getter for watcher "${this.expression}"`);
            } else {
                throw e;
            }
        } finally {
            // "touch" every property so they are all tracked as
            // dependencies for deep watching
            if (this.deep) {
                traverse(value);
            }
            popTarget();
            this.cleanupDeps();
        }
        return value;
    }

    /**
     * Add a dependency to this directive.
     */
    addDep(dep: Dep) {
        const id = dep.id;
        if (!this.newDepIds.has(id)) {
            this.newDepIds.add(id);
            this.newDeps.push(dep);
            if (!this.depIds.has(id)) {
                dep.addSub(this);
            }
        }
    }

    /**
     * Clean up for dependency collection.
     */
    cleanupDeps() {
        let i = this.deps.length;
        while (i--) {
            const dep = this.deps[i];
            if (!this.newDepIds.has(dep.id)) {
                dep.removeSub(this);
            }
        }
        let tmp = this.depIds;
        this.depIds = this.newDepIds;
        this.newDepIds = tmp;
        this.newDepIds.clear();
        tmp = this.deps;
        this.deps = this.newDeps;
        this.newDeps = tmp;
        this.newDeps.length = 0;
    }
    // ...
}
```

当我们去实例化一个渲染 watcher 的时候，首先进入 watcher 的构造函数逻辑，然后会执行它的 this.get() 方法，进入 get 函数，首先会执行：`pushTarget(this)`

pushTarget 的定义在 src/core/observer/dep.js 中：

```js
export function pushTarget(_target: Watcher) {
    if (Dep.target) targetStack.push(Dep.target);
    Dep.target = _target;
}
```

实际上就是把 Dep.target 赋值为当前的渲染 watcher 并压栈（为了恢复用）。接着又执行了：`value = this.getter.call(vm, vm)`，this.getter 对应就是 updateComponent 函数，这实际上就是在执行：`vm._update(vm._render(), hydrating)`。它会先执行 vm.\_render() 方法生成 VNode，并且在这个过程中会对 vm 上的数据访问，这个时候就触发了数据对象的 getter。

每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 `Dep.target.addDep(this)` 去完成依赖收集。

在完成依赖收集后还会做一些操作

```js
if (this.deep) {
    traverse(value);
}
popTarget();
this.cleanupDeps();
```

`traverse(value)` 递归去访问 value，触发它所有子项的 getter。

`popTarget()` 实际上就是把 Dep.target 恢复成上一个状态，因为当前 vm 的数据依赖收集已经完成，那么对应的渲染 Dep.target 也需要改变。

最后执行：`this.cleanupDeps()` 移除掉旧的订阅。

为什么要移除旧的订阅？

考虑到一种场景，我们的模板会根据 v-if 去渲染不同子模板 a 和 b，当我们满足某种条件的时候渲染 a 的时候，会访问到 a 中的数据，这时候我们对 a 使用的数据添加了 getter，做了依赖收集，那么当我们去修改 a 的数据的时候，理应通知到这些订阅者。那么如果我们一旦改变了条件渲染了 b 模板，又会对 b 使用的数据添加了 getter，如果我们没有依赖移除的过程，那么这时候我去修改 a 模板的数据，会通知 a 数据的订阅的回调，这显然是有浪费的。

在 Vue1 中一个 Watcher 维护着一个指令，dom 和数据的关系，因此不需要 dom diff 算法，只需要比较数据的变化，如果数据变化了，就更新 dom。带来后果就是在内存中维护大量的 watcher，占用内存。

在 Vue2 中一个 Watcher 维护的是一个组件中的指令，dom 和数据间的关系，是基于组件的颗粒度来建立关系的。因此数据变化时需要进行组件内的 dom diff。页面如果存在大量组件依然会有内存方面的问题，这也就是业内为什么说 vue 不适合写大项目的原因。

### 派发更新

defineReactive setter 部分代码

```js
export function defineReactive(
    obj: Object,
    key: string,
    val: any,
    customSetter?: ?Function,
    shallow?: boolean
) {
    const dep = new Dep();
    let childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        set: function reactiveSetter(newVal) {
            const value = getter ? getter.call(obj) : val;
            /* eslint-disable no-self-compare */
            if (newVal === value || (newVal !== newVal && value !== value)) {
                return;
            }
            /* eslint-enable no-self-compare */
            if (process.env.NODE_ENV !== 'production' && customSetter) {
                customSetter();
            }
            // #7981: for accessor properties without setter
            if (getter && !setter) return;
            if (setter) {
                setter.call(obj, newVal);
            } else {
                val = newVal;
            }
            childOb = !shallow && observe(newVal);
            dep.notify(); //打电话通知，数据被修改
        }
    });
}
```

setter 的逻辑有 2 个关键的点，一个是 `childOb = !shallow && observe(newVal)`，如果 shallow 为 false 的情况，会对新设置的值变成一个响应式对象；另一个是 `dep.notify()`，通知所有的订阅者。

```js
// src/core/observer/dep.js
class Dep {
    // ...
    notify() {
        // stabilize the subscriber list first
        const subs = this.subs.slice();
        for (let i = 0, l = subs.length; i < l; i++) {
            subs[i].update();
        }
    }
}
```

```js
// src/core/observer/watcher.js
class Watcher {
    // ...
    update() {
        /* istanbul ignore else */
        if (this.computed) {
            if (this.dep.subs.length === 0) {
                // is accessed.
                this.dirty = true;
            } else {
                this.getAndInvoke(() => {
                    this.dep.notify();
                });
            }
        } else if (this.sync) {
            this.run();
        } else {
            queueWatcher(this);
        }
    }
}
```

这里对于 Watcher 的不同状态，会执行不同的逻辑，在一般组件数据更新的场景，会走到最后一个 `queueWatcher(this)` 的逻辑，

```js
// src/core/observer/scheduler.js
const queue: Array<Watcher> = [];
let has: { [key: number]: ?true } = {};
let waiting = false;
let flushing = false;
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
export function queueWatcher(watcher: Watcher) {
    const id = watcher.id;
    if (has[id] == null) {
        has[id] = true;
        if (!flushing) {
            queue.push(watcher);
        } else {
            // if already flushing, splice the watcher based on its id
            // if already past its id, it will be run next immediately.
            let i = queue.length - 1;
            while (i > index && queue[i].id > watcher.id) {
                i--;
            }
            queue.splice(i + 1, 0, watcher);
        }
        // queue the flush
        if (!waiting) {
            waiting = true;
            nextTick(flushSchedulerQueue);
        }
    }
}
```

Vue 并不会每次数据改变都触发 watcher 的回调，而是把这些 watcher 先添加到一个队列里，然后在 nextTick 后执行 flushSchedulerQueue。

```js
// src/core/observer/scheduler.js

let flushing = false;
let index = 0;
/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
    flushing = true;
    let watcher, id;

    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort((a, b) => a.id - b.id);

    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index = 0; index < queue.length; index++) {
        watcher = queue[index];
        if (watcher.before) {
            watcher.before();
        }
        id = watcher.id;
        has[id] = null;
        watcher.run();
        // in dev build, check and stop circular updates.
        if (process.env.NODE_ENV !== 'production' && has[id] != null) {
            circular[id] = (circular[id] || 0) + 1;
            if (circular[id] > MAX_UPDATE_COUNT) {
                warn(
                    'You may have an infinite update loop ' +
                        (watcher.user
                            ? `in watcher with expression "${watcher.expression}"`
                            : `in a component render function.`),
                    watcher.vm
                );
                break;
            }
        }
    }

    // keep copies of post queues before resetting state
    const activatedQueue = activatedChildren.slice();
    const updatedQueue = queue.slice();

    resetSchedulerState();

    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);

    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
        devtools.emit('flush');
    }
}
```

`queue.sort((a, b) => a.id - b.id)` 对队列做了从小到大的排序，这么做主要有以下要确保以下几点：

1. 组件的更新由父到子；因为父组件的创建过程是先于子的，所以 watcher 的创建也是先父后子，执行顺序也应该保持先父后子。
2. 用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。
3. 如果一个组件在父组件的 watcher 执行期间被销毁，那么它对应的 watcher 执行都可以被跳过，所以父组件的 watcher 应该先执行。

队列遍历

在对 queue 排序后，接着就是要对它做遍历，拿到对应的 watcher，执行 watcher.run()。这里需要注意一个细节，在遍历的时候每次都会对 queue.length 求值，因为在 watcher.run() 的时候，很可能用户会再次添加新的 watcher，这样会再次执行到 queueWatcher，如下：

```js
export function queueWatcher(watcher: Watcher) {
    const id = watcher.id;
    if (has[id] == null) {
        has[id] = true;
        if (!flushing) {
            queue.push(watcher);
        } else {
            // if already flushing, splice the watcher based on its id
            // if already past its id, it will be run next immediately.
            let i = queue.length - 1;
            while (i > index && queue[i].id > watcher.id) {
                i--;
            }
            queue.splice(i + 1, 0, watcher);
        }
        // ...
    }
}
```

可以看到，这时候 flushing 为 true，就会执行到 else 的逻辑，然后就会从后往前找，找到第一个待插入 watcher 的 id 比当前队列中 watcher 的 id 大的位置。把 watcher 按照 id 的插入到队列中，因此 queue 的长度发生了变化。

状态恢复

这个过程就是执行 resetSchedulerState 函数，

```js
// src/core/observer/scheduler.js
const queue: Array<Watcher> = [];
let has: { [key: number]: ?true } = {};
let circular: { [key: number]: number } = {};
let waiting = false;
let flushing = false;
let index = 0;
/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    if (process.env.NODE_ENV !== 'production') {
        circular = {};
    }
    waiting = flushing = false;
}
```

把这些控制流程状态的一些变量恢复到初始值，把 watcher 队列清空。

分析 watcher.run() 的逻辑

```js
// src/core/observer/watcher.js
class Watcher {
    /**
     * Scheduler job interface.
     * Will be called by the scheduler.
     */
    run() {
        if (this.active) {
            this.getAndInvoke(this.cb);
        }
    }

    getAndInvoke(cb: Function) {
        const value = this.get();
        if (
            value !== this.value ||
            // Deep watchers and watchers on Object/Arrays should fire even
            // when the value is the same, because the value may
            // have mutated.
            isObject(value) ||
            this.deep
        ) {
            // set new value
            const oldValue = this.value;
            this.value = value;
            this.dirty = false;
            if (this.user) {
                try {
                    cb.call(this.vm, value, oldValue);
                } catch (e) {
                    handleError(e, this.vm, `callback for watcher "${this.expression}"`);
                }
            } else {
                cb.call(this.vm, value, oldValue);
            }
        }
    }
}
```

run 函数实际上就是执行 this.getAndInvoke 方法，并传入 watcher 的回调函数。getAndInvoke 函数逻辑也很简单，先通过 this.get() 得到它当前的值，然后做判断，如果满足新旧值不等、新值是对象类型、deep 模式任何一个条件，则执行 watcher 的回调，注意回调函数执行的时候会把第一个和第二个参数传入新值 value 和旧值 oldValue，

那么对于渲染 watcher 而言，它在执行 this.get() 方法求值的时候，会执行 getter 方法：

```js
updateComponent = () => {
    vm._update(vm._render(), hydrating);
};
```

所以这就是当我们去修改组件相关的响应式数据的时候，会触发组件重新渲染的原因，接着就会重新执行 patch 的过程。

`$set` 原理 ？

```js
// src/core/observer/index.js
export function set(target: Array<any> | Object, key: any, val: any): any {
    if (process.env.NODE_ENV !== 'production' && (isUndef(target) || isPrimitive(target))) {
        warn(
            `Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`
        );
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        return val;
    }
    if (key in target && !(key in Object.prototype)) {
        target[key] = val;
        return val;
    }
    const ob = (target: any).__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
        process.env.NODE_ENV !== 'production' &&
            warn(
                'Avoid adding reactive properties to a Vue instance or its root $data ' +
                    'at runtime - declare it upfront in the data option.'
            );
        return val;
    }
    if (!ob) {
        target[key] = val;
        return val;
    }
    defineReactive(ob.value, key, val);
    ob.dep.notify();
    return val;
}
```

set 方法接收 3 个参数，target 可能是数组或者是普通对象，key 代表的是数组的下标或者是对象的键值，val 代表添加的值。

1. 首先判断如果 target 是数组且 key 是一个合法的下标，则之前通过 splice 去添加进数组然后返回，这里的 splice 其实已经不仅仅是原生数组的 splice 了
2. 接着又判断 key 已经存在于 target 中，则直接赋值返回，因为这样的变化是可以观测到了
3. 接着再获取到 target.**ob** 并赋值给 ob，之前分析过它是在 Observer 的构造函数执行的时候初始化的，表示 Observer 的一个实例，如果它不存在，则说明 target 不是一个响应式的对象，则直接赋值并返回。
4. 最后通过 defineReactive(ob.value, key, val) 把新添加的属性变成响应式对象，然后再通过 ob.dep.notify() 手动的触发依赖通知，

Vue 对数组的处理？

```js
// src/core/observer/index.js
export class Observer {
    constructor(value: any) {
        this.value = value;
        this.dep = new Dep();
        this.vmCount = 0;
        def(value, '__ob__', this);
        if (Array.isArray(value)) {
            const augment = hasProto ? protoAugment : copyAugment;
            augment(value, arrayMethods, arrayKeys);
            this.observeArray(value);
        } else {
            // ...
        }
    }
}

function protoAugment(target, src: Object, keys: any) {
    target.__proto__ = src;
}

function copyAugment(target: Object, src: Object, keys: Array<string>) {
    for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        def(target, key, src[key]);
    }
}
```

protoAugment 方法是直接把 target.**proto** 原型直接修改为 src，而 copyAugment 方法是遍历 keys，通过 def，也就是 Object.defineProperty 去定义它自身的属性值。对于大部分现代浏览器都会走到 protoAugment，那么它实际上就把 value 的原型指向了 arrayMethods：

```js
// src/core/observer/array.js
import { def } from '../util/index';

const arrayProto = Array.prototype;
export const arrayMethods = Object.create(arrayProto);

const methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
    // cache original method
    const original = arrayProto[method];
    def(arrayMethods, method, function mutator(...args) {
        const result = original.apply(this, args);
        const ob = this.__ob__;
        let inserted;
        switch (method) {
            case 'push':
            case 'unshift':
                inserted = args;
                break;
            case 'splice':
                inserted = args.slice(2);
                break;
        }
        if (inserted) ob.observeArray(inserted);
        // notify change
        ob.dep.notify();
        return result;
    });
});
```

可以看到，arrayMethods 首先继承了 Array，然后对数组中所有能改变数组自身的方法，如 push、pop 等这些方法进行重写。重写后的方法会先执行它们本身原有的逻辑，并对能增加数组长度的 3 个方法 push、unshift、splice 方法做了判断，获取到插入的值，然后把新添加的值变成一个响应式对象，并且再调用 ob.dep.notify() 手动触发依赖通知
