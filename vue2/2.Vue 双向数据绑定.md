# Vue 双向数据绑定

涉及到的技术

- Object.defineProperty
- Observer
- Watcher
- Dep
- Directive

## 认识Object.defineProperty

```js
function defineReactive(data, key, value) {
    Object.defineProperty(data, key, {
        configurable: true,
        enumerable: true,
        get: function () {
            console.log(`get ${value}`);
            return value;
        },
        set: function (newVal) {
            console.log(`set key: ${key} value ${newVal}`);
            value = newVal;
        }
    });
}

function observer(data) {
    Object.keys(data).forEach(key => {
        defineReactive(data, key, data[key]);
    });
}

let obj = { a: 1 };
let arr = [1, 2, 3];

observer(obj);
observer(arr);

arr.unshift(4);
// get 3
// get 2
// set key: 2 value 2
// get 1
// set key: 1 value 1
// set key: 0 value 4
```

object.defineProperty 可以对对象某个 key 值的重写，只能重写已有的值，对于新增的 key值无法重写。

执行 arr.unshift(4) 为什么频繁的触发 get 和 set？

因为数组在内存中的存储是连续的，存储的是数组的起始位置和长度。执行 arr.unshift(4)，会先增加数组长度，取出原先最后一位放到现在的最后一位。原先只对下标为 0，1，2重写了 get，set 没有对新增的下标 3 重写，因此只会触发下标为 2 的get，不存在下标为 3 的 set。同理一次对下标 0，1做同样的操作。最后将要 4，填到下标为 0 的位置，即触发 0 的 set。

## 响应式数据原理

![observer](../images/observer.png)



在 Vue1 中一个 Watcher 维护着一个指令，dom和数据的关系，因此不需要 dom diff 算法，只需要比较数据的变化，如果数据变化了，就更新 dom。带来后果就是在内存中维护大量的 watcher，占用内存。

在 Vue2 中一个 Watcher 维护的是一个组件中的指令，dom和数据间的关系，是基于组件的颗粒度来建立关系的。因此数据变化时需要进行组件内的 dom diff。页面如果存在大量组件依然会有内存方面的问题，这也就是业内为什么说 vue 不适合写大项目的原因。