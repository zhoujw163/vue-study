# Vue 双向数据绑定

涉及到的技术

-   Object.defineProperty
-   Observer
-   Watcher
-   Dep
-   Directive

## 认识 Object.defineProperty

```js
function defineReactive(data, key, value) {
    Object.defineProperty(data, key, {
        configurable: true,
        enumerable: true,
        get: function () {
            console.log(`get ${value}`);
            return value;
        },
        set: function (newVal) {
            console.log(`set key: ${key} value ${newVal}`);
            value = newVal;
        }
    });
}

function observer(data) {
    Object.keys(data).forEach(key => {
        defineReactive(data, key, data[key]);
    });
}

let obj = { a: 1 };
let arr = [1, 2, 3];

observer(obj);
observer(arr);

arr.unshift(4);
// get 3
// get 2
// set key: 2 value 2
// get 1
// set key: 1 value 1
// set key: 0 value 4
```

object.defineProperty 可以对对象某个 key 值进行重写，只能重写已有的值，对于新增的 key 值无法重写。

执行 arr.unshift(4) 为什么频繁的触发 get 和 set？

因为数组在内存中的存储是连续的，存储的是数组的起始位置和长度。执行 arr.unshift(4)，会先增加数组长度，取出原先最后一位放到现在的最后一位。原先只对下标为 0，1，2 重写了 get，set 没有对新增的下标 3 重写，因此只会触发下标为 2 的 get，不触发下标为 3 的 set。同理一次对下标 0，1 做同样的操作。最后将要 4，填到下标为 0 的位置，即触发 0 的 set。

## 响应式数据原理

![observer](../images/observer.png)

### 数据监听过程

在 Vue 初始化阶段，执行 \_init 时会执行 initState(vm)。 initState 方法主要对 props、data、methods、computed、watch 进行初始化操作。这里重点分析 initProps 和 initData。

```js
// src/core/instance/state.js
export function initState(vm: Component) {
    vm._watchers = [];
    const opts = vm.$options;
    if (opts.props) initProps(vm, opts.props);
    if (opts.methods) initMethods(vm, opts.methods);
    if (opts.data) {
        initData(vm);
    } else {
        observe((vm._data = {}), true /* asRootData */);
    }
    if (opts.computed) initComputed(vm, opts.computed);
    if (opts.watch && opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch);
    }
}
```

**分析 initProps 和 initData：**

```js
// src/core/instance/state.js
function initProps(vm: Component, propsOptions: Object) {
    const propsData = vm.$options.propsData || {};
    const props = (vm._props = {});
    const keys = (vm.$options._propKeys = []);
    // ...代码省略
    for (const key in propsOptions) {
        keys.push(key);
        // ...代码省略
        defineReactive(props, key, value);
        if (!(key in vm)) {
            proxy(vm, `_props`, key);
        }
    }
    // ...代码省略
}

function initData(vm: Component) {
    let data = vm.$options.data;
    // ...代码省略
    // proxy data on instance
    const keys = Object.keys(data);
    const props = vm.$options.props;
    const methods = vm.$options.methods;
    let i = keys.length;
    while (i--) {
        const key = keys[i];
        // ...代码省略
        proxy(vm, `_data`, key);
    }
    // observe data
    observe(data, true /* asRootData */);
}
```

props 和 data 初始化过程主要做了两件事。

1. 通过 proxy 方法将数据代理到 vm 上。如：`vm._props.xxx ==> vm.xxx`
   `vm._data.xxx ==> vm.xxx`。
2. Vue 遵循单向数据流的原则，props 由父组件传递过来，因此无需 observer，直接使用 defineReactive 方法把 props 每个值变成响应式；而 data 需要进行 observer，在把 data 变成响应式。

**为什么要将数据代理到 vue 实例对象上？**

下面是一段 template 编译后的 js 代码

```html
<div id="app">
    <div>
        <h2 v-if="message">{{message}}</h2>
        <button @click="showName">showName</button>
        <div v-if="v">
            <div>
                <p>我爱你</p>
                <p>你爱我</p>
                <p>蜜雪冰城甜蜜蜜</p>
            </div>
        </div>
    </div>
</div>
```

```js
// this ==> vm
with (this) {
    return _c('div', { attrs: { id: 'app' } }, [
        _c('div', [
            message ? _c('h2', [_v(_s(message))]) : _e(),
            _v(' '),
            _c('button', { on: { click: showName } }, [_v('showName')]),
            _v(' '),
            v ? _c('div', [_m(0)]) : _e()
        ])
    ]);
}
```

可以看到 Vue 使用 with 将 this（实例对象）插入到作用域链，因此会访问到实例上的变量，这就解释了为什么要将数据代理到实例对象上。

**分析 observer：**

observe 的功能就是用来监测数据的变化，它的定义在 src/core/observer/index.js 中：

```js
export function observe(value: any, asRootData: ?boolean): Observer | void {
    if (!isObject(value) || value instanceof VNode) {
        return;
    }
    let ob: Observer | void;
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
        ob = value.__ob__;
    } else if (
        shouldObserve &&
        !isServerRendering() &&
        (Array.isArray(value) || isPlainObject(value)) &&
        Object.isExtensible(value) &&
        !value._isVue
    ) {
        ob = new Observer(value); //
    }
    if (asRootData && ob) {
        ob.vmCount++;
    }
    return ob;
}
```

observe 方法的作用就是给非 VNode 的对象类型数据添加一个 Observer，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 Observer 对象实例。

```js
export class Observer {
    value: any;
    dep: Dep;
    vmCount: number; // number of vms that have this object as root $data

    constructor(value: any) {
        this.value = value;
        this.dep = new Dep();
        this.vmCount = 0;
        def(value, '__ob__', this);
        if (Array.isArray(value)) {
            if (hasProto) {
                // [12，4334，].__proto__= arrayMethods
                protoAugment(value, arrayMethods);
            } else {
                copyAugment(value, arrayMethods, arrayKeys);
            }
            this.observeArray(value);
        } else {
            this.walk(value);
        }
    }

    walk(obj: Object) {
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
            defineReactive(obj, keys[i]);
        }
    }

    observeArray(items: Array<any>) {
        for (let i = 0, l = items.length; i < l; i++) {
            observe(items[i]);
        }
    }
}
```

Observer 的作用就是重写对象的 getter 和 setter，用于依赖收集和派发更新。

Vue 会对 Array 和 Object 分别处理，对象类型直接调用 defineReactive 进行处理，而数组类型是调用 protoAugment 或 copyAugment 处理（重写原型方法）。

**defineReactive：**

```js
export function defineReactive(
    obj: Object,
    key: string,
    val: any,
    customSetter?: ?Function,
    shallow?: boolean
) {
    const dep = new Dep();
    const property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
        return;
    }

    // cater for pre-defined getter/setters
    const getter = property && property.get;
    const setter = property && property.set;
    if ((!getter || setter) && arguments.length === 2) {
        val = obj[key];
    }

    let childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
            const value = getter ? getter.call(obj) : val;
            if (Dep.target) {
                dep.depend();
                if (childOb) {
                    childOb.dep.depend();
                    if (Array.isArray(value)) {
                        dependArray(value);
                    }
                }
            }
            return value;
        },
        set: function reactiveSetter(newVal) {
            const value = getter ? getter.call(obj) : val;
            /* eslint-disable no-self-compare */
            if (newVal === value || (newVal !== newVal && value !== value)) {
                return;
            }
            /* eslint-enable no-self-compare */
            if (process.env.NODE_ENV !== 'production' && customSetter) {
                customSetter();
            }
            // #7981: for accessor properties without setter
            if (getter && !setter) return;
            if (setter) {
                setter.call(obj, newVal);
            } else {
                val = newVal;
            }
            childOb = !shallow && observe(newVal);
            dep.notify(); // 通知，数据被修改
        }
    });
}
```

defineReactive 函数最开始初始化 Dep 对象的实例，接着拿到 obj 的属性描述符，然后对子对象递归调用 observe 方法，这样就保证了无论 obj 的结构多复杂，它的所有子属性也能变成响应式的对象，这样我们访问或修改 obj 中一个嵌套较深的属性，也能触发 getter 和 setter。最后利用 Object.defineProperty 去给 obj 的属性 key 添加 getter 和 setter。

### 依赖收集

当对数据对象的访问会触发他们的 getter 方法，那么这些对象什么时候被访问呢？

Vue 的 mount 过程是通过 mountComponent 函数，mountComponent 会通过 render 函数生成 VNode，这时会触发 getter。

```js
// src/core/instance/lifecycle.js
export function mountComponent(vm: Component, el: ?Element, hydrating?: boolean): Component {
    //...代码省略
    updateComponent = () => {
        //TAG:绑定render
        vm._update(vm._render(), hydrating);
    };

    new Watcher(
        vm,
        updateComponent,
        noop,
        {
            before() {
                if (vm._isMounted && !vm._isDestroyed) {
                    callHook(vm, 'beforeUpdate');
                }
            }
        },
        true /* isRenderWatcher */
    );
}
```

先看 Watcher 和 Dep 的代码

```js
import type Watcher from './watcher';
import { remove } from '../util/index';

let uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
export default class Dep {
    static target: ?Watcher;
    id: number;
    subs: Array<Watcher>;

    constructor() {
        this.id = uid++;
        this.subs = [];
    }

    addSub(sub: Watcher) {
        this.subs.push(sub);
    }

    removeSub(sub: Watcher) {
        remove(this.subs, sub);
    }

    depend() {
        if (Dep.target) {
            Dep.target.addDep(this);
        }
    }

    notify() {
        // stabilize the subscriber list first
        const subs = this.subs.slice();
        for (let i = 0, l = subs.length; i < l; i++) {
            subs[i].update();
        }
    }
}

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
const targetStack = [];

export function pushTarget(_target: ?Watcher) {
    if (Dep.target) targetStack.push(Dep.target);
    Dep.target = _target;
}

export function popTarget() {
    Dep.target = targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
}
```

Dep 是一个 Class，它定义了一些属性和方法，这里需要特别注意的是它有一个静态属性 target，会存储全局唯一 Watcher，因为在同一时间只能有一个全局的 Watcher 被计算，另外它的自身属性 subs 也是 Watcher 的数组。

```js
// src/core/observer/watcher.js
let uid = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
export default class Watcher {
    vm: Component;
    expression: string;
    cb: Function;
    id: number;
    deep: boolean;
    user: boolean;
    computed: boolean;
    sync: boolean;
    dirty: boolean;
    active: boolean;
    dep: Dep;
    deps: Array<Dep>;
    newDeps: Array<Dep>;
    depIds: SimpleSet;
    newDepIds: SimpleSet;
    before: ?Function;
    getter: Function;
    value: any;

    constructor(
        vm: Component,
        expOrFn: string | Function,
        cb: Function,
        options?: ?Object,
        isRenderWatcher?: boolean
    ) {
        this.vm = vm;
        if (isRenderWatcher) {
            vm._watcher = this;
        }
        vm._watchers.push(this);
        // options
        if (options) {
            this.deep = !!options.deep;
            this.user = !!options.user;
            this.computed = !!options.computed;
            this.sync = !!options.sync;
            this.before = options.before;
        } else {
            this.deep = this.user = this.computed = this.sync = false;
        }
        this.cb = cb;
        this.id = ++uid; // uid for batching
        this.active = true;
        this.dirty = this.computed; // for computed watchers
        this.deps = [];
        this.newDeps = [];
        this.depIds = new Set();
        this.newDepIds = new Set();
        this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
        // parse expression for getter
        if (typeof expOrFn === 'function') {
            this.getter = expOrFn;
        } else {
            this.getter = parsePath(expOrFn);
            if (!this.getter) {
                this.getter = function () {};
                process.env.NODE_ENV !== 'production' &&
                    warn(
                        `Failed watching path: "${expOrFn}" ` +
                            'Watcher only accepts simple dot-delimited paths. ' +
                            'For full control, use a function instead.',
                        vm
                    );
            }
        }
        if (this.computed) {
            this.value = undefined;
            this.dep = new Dep();
        } else {
            this.value = this.get();
        }
    }

    /**
     * Evaluate the getter, and re-collect dependencies.
     */
    get() {
        pushTarget(this);
        let value;
        const vm = this.vm;
        try {
            value = this.getter.call(vm, vm);
        } catch (e) {
            if (this.user) {
                handleError(e, vm, `getter for watcher "${this.expression}"`);
            } else {
                throw e;
            }
        } finally {
            // "touch" every property so they are all tracked as
            // dependencies for deep watching
            if (this.deep) {
                traverse(value);
            }
            popTarget();
            this.cleanupDeps();
        }
        return value;
    }

    /**
     * Add a dependency to this directive.
     */
    addDep(dep: Dep) {
        const id = dep.id;
        if (!this.newDepIds.has(id)) {
            this.newDepIds.add(id);
            this.newDeps.push(dep);
            if (!this.depIds.has(id)) {
                dep.addSub(this);
            }
        }
    }

    /**
     * Clean up for dependency collection.
     */
    cleanupDeps() {
        let i = this.deps.length;
        while (i--) {
            const dep = this.deps[i];
            if (!this.newDepIds.has(dep.id)) {
                dep.removeSub(this);
            }
        }
        let tmp = this.depIds;
        this.depIds = this.newDepIds;
        this.newDepIds = tmp;
        this.newDepIds.clear();
        tmp = this.deps;
        this.deps = this.newDeps;
        this.newDeps = tmp;
        this.newDeps.length = 0;
    }
    // ...
}
```

当我们去实例化一个渲染 watcher 的时候，首先进入 watcher 的构造函数逻辑，然后会执行它的 this.get() 方法，进入 get 函数，首先会执行：`pushTarget(this)`

pushTarget 的定义在 src/core/observer/dep.js 中：

```js
export function pushTarget(_target: Watcher) {
    if (Dep.target) targetStack.push(Dep.target);
    Dep.target = _target;
}
```

实际上就是把 Dep.target 赋值为当前的渲染 watcher 并压栈（为了恢复用）。接着又执行了：`value = this.getter.call(vm, vm)`，this.getter 对应就是 updateComponent 函数，这实际上就是在执行：`vm._update(vm._render(), hydrating)`。它会先执行 vm.\_render() 方法生成 VNode，并且在这个过程中会对 vm 上的数据访问，这个时候就触发了数据对象的 getter。

每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 `Dep.target.addDep(this)` 去完成依赖收集。

在完成依赖收集后还会做一些操作

```js
if (this.deep) {
    traverse(value);
}
popTarget();
this.cleanupDeps();
```

`traverse(value)` 递归去访问 value，触发它所有子项的 getter。

`popTarget()` 实际上就是把 Dep.target 恢复成上一个状态，因为当前 vm 的数据依赖收集已经完成，那么对应的渲染Dep.target 也需要改变。

最后执行：`this.cleanupDeps()` 移除掉旧的订阅。

为什么要移除旧的订阅？

考虑到一种场景，我们的模板会根据 v-if 去渲染不同子模板 a 和 b，当我们满足某种条件的时候渲染 a 的时候，会访问到 a 中的数据，这时候我们对 a 使用的数据添加了 getter，做了依赖收集，那么当我们去修改 a 的数据的时候，理应通知到这些订阅者。那么如果我们一旦改变了条件渲染了 b 模板，又会对 b 使用的数据添加了 getter，如果我们没有依赖移除的过程，那么这时候我去修改 a 模板的数据，会通知 a 数据的订阅的回调，这显然是有浪费的。

### 派发更新

在 Vue1 中一个 Watcher 维护着一个指令，dom 和数据的关系，因此不需要 dom diff 算法，只需要比较数据的变化，如果数据变化了，就更新 dom。带来后果就是在内存中维护大量的 watcher，占用内存。

在 Vue2 中一个 Watcher 维护的是一个组件中的指令，dom 和数据间的关系，是基于组件的颗粒度来建立关系的。因此数据变化时需要进行组件内的 dom diff。页面如果存在大量组件依然会有内存方面的问题，这也就是业内为什么说 vue 不适合写大项目的原因。
